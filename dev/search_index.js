var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#AssemblyLine2PC.raw_materials","page":"API reference","title":"AssemblyLine2PC.raw_materials","text":"raw_materials\n\nString ordered vector of raw resources that anchor all cost tuples produced by AssemblyLine2PC.jl.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AssemblyLine2PC.build_skeletontree-Tuple{}","page":"API reference","title":"AssemblyLine2PC.build_skeletontree","text":"build_skeletontree()\n\nCreate an empty recipe graph seeded with vertices for every known item. Edges only store ingredient ratios; raw-resource footprints are populated later by datatree.\n\n\n\n\n\n","category":"method"},{"location":"api/#AssemblyLine2PC.cost-Tuple{Any, Any}","page":"API reference","title":"AssemblyLine2PC.cost","text":"cost(graph, item)\n\nReturn the total raw-material tuple required to produce a single unit of item.\n\nThe tuple ordering matches raw_materials so each entry represents the per-unit demand for the corresponding raw resource. This helper is convenient when you already have a pre-computed graph from datatree and need to inspect multiple items without re-running the traversal.\n\n\n\n\n\n","category":"method"},{"location":"api/#AssemblyLine2PC.datatree-Tuple{}","page":"API reference","title":"AssemblyLine2PC.datatree","text":"datatree()\n\nConstruct the complete crafting graph for Assembly Line 2.\n\nThe resulting MetaGraph stores per-item resource footprints as vertex metadata so downstream analysis can reuse the same structure without re-traversing recipe data. The tuple stored on each vertex aligns with raw_materials, ensuring deterministic indexing for raw material accounting and visualization routines.\n\n\n\n\n\n","category":"method"},{"location":"api/#AssemblyLine2PC.nminers","page":"API reference","title":"AssemblyLine2PC.nminers","text":"nminers(item, rate=1, data=datatree())\n\nEstimate how many Miners are required to maintain rate units per second of item.\n\nEach Miner extracts 5 units of raw material per second in Assembly Line 2. The function uses total_material to compute the throughput requirements and then converts that to the number of working Miners needed on the resource patches.\n\n\n\n\n\n","category":"function"},{"location":"api/#AssemblyLine2PC.topspeed","page":"API reference","title":"AssemblyLine2PC.topspeed","text":"topspeed(item, miners, data=datatree())\n\nCompute the theoretical maximum units per second of item that miners active Miners can support.\n\nThis is the inverse of nminers and is useful when you know the amount of extraction capacity available and want to determine the production ceiling before optimizing factory layout details.\n\n\n\n\n\n","category":"function"},{"location":"api/#AssemblyLine2PC.total_material","page":"API reference","title":"AssemblyLine2PC.total_material","text":"total_material(item, rate, data=datatree())\n\nCalculate the total raw-material throughput required to sustain rate units per second of item.\n\nThis multiplies cost by the desired production rate so downstream sizing and balancing can be performed in a single step.\n\n\n\n\n\n","category":"function"},{"location":"api/#AssemblyLine2PC.vertex_costs","page":"API reference","title":"AssemblyLine2PC.vertex_costs","text":"vertex_costs(graph, vertex, speed=1)\n\nReturn the resource footprint tuple for vertex, scaled by speed units per second. The tuple ordering follows raw_materials.\n\n\n\n\n\n","category":"function"},{"location":"api/#AssemblyLine2PC.vertex_costs!","page":"API reference","title":"AssemblyLine2PC.vertex_costs!","text":"vertex_costs!(costs, graph, vertex, speed=1)\n\nAccumulate raw-resource demand for vertex into costs, scaling contributions by speed units per second.\n\n\n\n\n\n","category":"function"},{"location":"performance/#Performance-tuning","page":"Performance tuning","title":"Performance tuning","text":"AssemblyLine2PC ships efficient defaults, but large-scale analyses and reporting pipelines can benefit from a few best practices.","category":"section"},{"location":"performance/#Reuse-the-data-graph","page":"Performance tuning","title":"Reuse the data graph","text":"Calling datatree constructs the entire recipe graph. The traversal is fast but still non-trivial—reuse the resulting MetaGraph whenever possible:\n\njulia> tree = datatree();\n\njulia> map(item -> cost(tree, item), [\"ElectricEngine\", \"NProcessor\"])\n2-element Vector{NTuple{23, Int64}}:\n (...)","category":"section"},{"location":"architecture/#architecture-tour","page":"Architecture","title":"Architecture overview","text":"Pages = [\"architecture.md\"]\nDepth = 3","category":"section"},{"location":"architecture/#Data-ingestion-pipeline","page":"Architecture","title":"Data ingestion pipeline","text":"AssemblyLine2PC constructs a layered MetaGraph G where vertex are all the items in the game encode as name String. Weighted edges encode ingredient ratios for its recipe, when item1 recipe requires n units of item2, the graph G has an edge item1>n>item2.  For example, raw-materials are kind of \"leaves\". The datatree builder stitches together transformer, maker, and radioactive recipes from the raw datasets defined in Data.jl.\n\nSkeleton graph – build_skeletontree creates vertices for every item with initial zero resource tuples, and adds edges for all recipes.\nCost accumulation – vertex_costs recursively tallies raw resource demand (total number of raw-materials units needed to produce 1u of item), storing the result directly on the vertex for constant-time lookups.\nTopological traversal – datatree Topological order ensures downstream costs are always available when needed.\n\ntip: Tip\nThe tuple stored on each vertex aligns with raw_materials. Keep this ordering in mind when performing manual indexing, or prefer helper functions such as cost and total_material to avoid off-by-one mistakes.","category":"section"},{"location":"architecture/#Extending-the-recipe-set","page":"Architecture","title":"Extending the recipe set","text":"Recipes are grouped by production tier in RECIPES. Adding new content usually requires updating the dataset definitions and optionally attaching annotations to new vertex types. A typical extension looks like:\n\nusing AssemblyLine2PC\n\nrecipes = AssemblyLine2PC.mk3  # start from an existing tier\npush!(recipes, \"FusionCell\" => [(\"SuperAlloy\", 2), (\"CryoFuel\", 1)])\n\ntree = datatree()\nvertex_data = tree[\"FusionCell\"]\n\nBecause the graph is recomputed from scratch, modifications remain deterministic and cache-friendly for documentation builds and tests.","category":"section"},{"location":"architecture/#Related-API","page":"Architecture","title":"Related API","text":"","category":"section"},{"location":"architecture/#AssemblyLine2PC.build_skeletontree","page":"Architecture","title":"AssemblyLine2PC.build_skeletontree","text":"build_skeletontree()\n\nCreate an empty recipe graph seeded with vertices for every known item. Edges only store ingredient ratios; raw-resource footprints are populated later by datatree.\n\n\n\n\n\n","category":"function"},{"location":"architecture/#AssemblyLine2PC.datatree","page":"Architecture","title":"AssemblyLine2PC.datatree","text":"datatree()\n\nConstruct the complete crafting graph for Assembly Line 2.\n\nThe resulting MetaGraph stores per-item resource footprints as vertex metadata so downstream analysis can reuse the same structure without re-traversing recipe data. The tuple stored on each vertex aligns with raw_materials, ensuring deterministic indexing for raw material accounting and visualization routines.\n\n\n\n\n\n","category":"function"},{"location":"architecture/#AssemblyLine2PC.vertex_costs","page":"Architecture","title":"AssemblyLine2PC.vertex_costs","text":"vertex_costs(graph, vertex, speed=1)\n\nReturn the resource footprint tuple for vertex, scaled by speed units per second. The tuple ordering follows raw_materials.\n\n\n\n\n\n","category":"function"},{"location":"architecture/#AssemblyLine2PC.vertex_costs!","page":"Architecture","title":"AssemblyLine2PC.vertex_costs!","text":"vertex_costs!(costs, graph, vertex, speed=1)\n\nAccumulate raw-resource demand for vertex into costs, scaling contributions by speed units per second.\n\n\n\n\n\n","category":"function"},{"location":"#AssemblyLine2PC","page":"Home","title":"AssemblyLine2PC","text":"Welcome to the documentation portal for AssemblyLine2PC.jl, the Julia toolkit for analyzing Assembly Line 2 production graphs. The package ships the full recipe data set together with helpers for computing material requirements, sizing mining fleets, and rendering readable build reports.\n\nUse the navigation sidebar to explore:\n\nArchitecture – how the data graph is constructed and how to extend it.\nPerformance tuning – tips for squeezing the most out of the traversal and reporting utilities.\nAPI reference – detailed signatures and docstrings for public entry points.","category":"section"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"#Install","page":"Home","title":"Install","text":"import Pkg\nPkg.develop(\"https://github.com/LauraBMo/MinerNumbers.jl.git\") # Dependency\nPkg.develop(\"https://github.com/LauraBMo/AssemblyLine2PC.jl.git\")","category":"section"},{"location":"#Naviagate-recipe","page":"Home","title":"Naviagate recipe","text":"For example, for AI Robot Bomber (\"AIRBomber\" in Data.jl) at max theoretical speed for your given limit of starters:\n\nusing AssemblyLine2PC\n\nVG = viewgraph();\n\nairb = \"AIRBomber\"\nmax_miners = 310 + 46*2  # Your starters limit for the job. \n\n# PrettyTables report showing intermediate makers, pack ratios, and raw demand…\nVG(airb; miners = max_miners)\n# Look up subfactories\nVG(airb, 4, 6; miners = max_miners)\n\nReady to dive deeper? Start with the architecture tour to understand how the graph is built.\n\nSee screenshots on how to navigate to graph.\n\nFirst, recipe for AI Robot Bober and second, recipe for the 4th element in AI Robot Bomber; that is Atomic Bomb. \n\n(Image: AIR Bomber main)\n\nAgain, recipe for Atomic Bomb needed to produce 0.2u/s of AI Robot Bomber. Second, subrecipe (4, 3) for Ignition System (which we need at 0.4u/s, see the title).\n\n(Image: AIR Bomber 4 and (4,6) subrecipes)","category":"section"}]
}
